<!doctype html>
<html lang="zh-CN">
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>æºå¯ç”¨æ€§æ£€æµ‹å™¨</title>
    <style>
        :root{--bg:#0f1724;--card:#0b1220;--muted:#94a3b8;--accent:#7c3aed;--success:#10b981;--warning:#f59e0b;--error:#ef4444;--glass: rgba(255,255,255,0.03)}
        html,body{height:100%;margin:0;font-family:Inter,system-ui,-apple-system,Segoe UI,Roboto,'Helvetica Neue',Arial;color:#e6eef8;background:linear-gradient(180deg,#071025 0%, #081226 60%);-webkit-font-smoothing:antialiased}
        .wrap{max-width:1200px;margin:20px auto;padding:20px}
        .card{background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));border-radius:14px;padding:18px;box-shadow:0 6px 30px rgba(2,6,23,0.6);border:1px solid rgba(255,255,255,0.03);margin-bottom:16px}
        h1{margin:0 0 6px;font-size:20px}
        p.lead{margin:0 0 16px;color:var(--muted);font-size:13px}

        .grid{display:grid;grid-template-columns:1fr 1fr;gap:16px}
        @media(max-width:768px){.grid{grid-template-columns:1fr}}

        .field{display:flex;flex-direction:column;margin-bottom:12px}
        label{font-size:13px;color:var(--muted);margin-bottom:6px}
        input[type="text"],input[type="url"],input[type="number"],textarea,select{background:var(--glass);border:1px solid rgba(255,255,255,0.04);padding:10px;border-radius:8px;color:#e6eef8;width:100%;box-sizing:border-box}
        textarea{resize:vertical;min-height:80px}
        
        .btn{display:inline-flex;align-items:center;gap:8px;padding:10px 16px;border-radius:10px;border:none;cursor:pointer;font-size:14px;transition:all 0.2s}
        .btn:disabled{opacity:0.5;cursor:not-allowed}
        .btn-primary{background:linear-gradient(90deg,var(--accent),#4f46e5);color:white}
        .btn-primary:hover:not(:disabled){transform:translateY(-1px)}
        .btn-success{background:linear-gradient(90deg,var(--success),#059669);color:white}
        .btn-warning{background:linear-gradient(90deg,var(--warning),#d97706);color:white}
        .btn-info{background:linear-gradient(90deg,#0ea5e9,#0284c7);color:white}
        .btn-ghost{background:transparent;border:1px solid rgba(255,255,255,0.04);color:var(--muted)}
        
        .btn-group{display:flex;gap:8px;flex-wrap:wrap}
        @media(max-width:480px){.btn-group{flex-direction:column}}

        .status{padding:8px 12px;border-radius:6px;font-size:12px;font-weight:500}
        .status-success{background:rgba(16,185,129,0.1);color:var(--success);border:1px solid rgba(16,185,129,0.2)}
        .status-error{background:rgba(239,68,68,0.1);color:var(--error);border:1px solid rgba(239,68,68,0.2)}
        .status-warning{background:rgba(245,158,11,0.1);color:var(--warning);border:1px solid rgba(245,158,11,0.2)}
        .status-pending{background:rgba(148,163,184,0.1);color:var(--muted);border:1px solid rgba(148,163,184,0.2)}

        .source-item{background:var(--glass);border:1px solid rgba(255,255,255,0.04);border-radius:8px;padding:12px;margin-bottom:8px}
        .source-header{display:flex;justify-content:space-between;align-items:center;margin-bottom:8px}
        .source-info{flex:1}
        .source-name{font-weight:500;color:#e6eef8;margin-bottom:2px}
        .source-url{font-size:11px;color:var(--muted)}
        .source-actions{display:flex;align-items:center;gap:8px}
        .source-status{padding:4px 8px;border-radius:4px;font-size:11px;font-weight:500}
        .manual-check-btn,.manual-mark-btn{background:var(--glass);border:1px solid rgba(255,255,255,0.1);color:var(--muted);padding:4px 6px;border-radius:4px;cursor:pointer;font-size:12px;transition:all 0.2s}
        .manual-check-btn:hover{background:rgba(16,185,129,0.1);border-color:var(--success);color:var(--success)}
        .manual-mark-btn:hover{background:rgba(245,158,11,0.1);border-color:var(--warning);color:var(--warning)}
        .source-details{font-size:12px;color:var(--muted);margin-bottom:8px}
        .source-results{display:grid;grid-template-columns:repeat(auto-fit,minmax(120px,1fr));gap:6px}
        .result-content{margin-top:8px;padding:8px;background:rgba(255,255,255,0.02);border-radius:4px;font-size:12px}
        .test-link{color:var(--success);text-decoration:none}
        .test-link:hover{text-decoration:underline}
        .error-message{color:var(--error)}
        
        .result-item{display:flex;justify-content:space-between;align-items:center;padding:4px 8px;background:rgba(255,255,255,0.02);border-radius:4px;font-size:11px}
        .result-label{color:var(--muted)}
        .result-status{font-weight:500}
        
        .progress-container{display:flex;align-items:center;gap:12px;margin:12px 0}
        .progress{flex:1;height:4px;background:rgba(255,255,255,0.05);border-radius:2px;overflow:hidden}
        .progress-bar{height:100%;background:linear-gradient(90deg,var(--accent),#4f46e5);transition:width 0.3s ease}
        .progress-text{font-size:12px;color:var(--muted);font-weight:500;min-width:30px;text-align:right}
        .timer-text{font-size:12px;color:var(--muted);margin-top:8px;text-align:center}
        
        .stats{display:grid;grid-template-columns:repeat(auto-fit,minmax(100px,1fr));gap:12px;margin-bottom:16px}
        .stat-item{text-align:center;padding:12px;background:var(--glass);border-radius:8px;border:1px solid rgba(255,255,255,0.04)}
        .stat-number{font-size:18px;font-weight:600;margin-bottom:4px}
        .stat-label{font-size:11px;color:var(--muted)}
        
        .filter-btn{cursor:pointer;transition:all 0.2s ease;user-select:none}
        .filter-btn:hover{background:rgba(255,255,255,0.08);transform:translateY(-1px)}
        .filter-btn.active{background:linear-gradient(90deg,var(--accent),#4f46e5);border-color:var(--accent)}
        .filter-btn.active .stat-label{color:white}
        .filter-btn.active .stat-number{color:white}
        
        .log{background:#020617;border-radius:8px;padding:12px;max-height:200px;overflow-y:auto;font-family:monospace;font-size:12px;line-height:1.4}
        .log-entry{margin-bottom:4px}
        .log-info{color:#94a3b8}
        .log-success{color:#10b981}
        .log-error{color:#ef4444}
        .log-warning{color:#f59e0b}
        
        .hidden{display:none}
        .loading{opacity:0.6;pointer-events:none}
        
        @media(max-width:480px){
            .wrap{padding:12px;margin:10px}
            h1{font-size:18px}
            .source-results{grid-template-columns:1fr}
            .stats{grid-template-columns:repeat(2,1fr)}
        }
    </style>
</head>
<body>
<div class="wrap">
    <div class="card">
        <h1>æºå¯ç”¨æ€§æ£€æµ‹å™¨</h1>
        <div id="statusIndicator" class="hidden" style="margin: 8px 0; padding: 8px 12px; background: rgba(59, 130, 246, 0.1); border: 1px solid rgba(59, 130, 246, 0.2); border-radius: 6px; font-size: 13px; color: #3b82f6;">
            ğŸ“Š å½“å‰æ˜¾ç¤ºå†å²æŠ¥å‘Šæ•°æ®
        </div>
        <p class="lead">æ£€æµ‹drpySæºç«™çš„å¯ç”¨æ€§çŠ¶æ€ï¼Œæ”¯æŒå¿«é€Ÿæ£€æµ‹ï¼ˆæ¨è+åˆ†ç±»ï¼‰å’Œå…¨é‡æ£€æµ‹æ¨¡å¼ã€‚æ”¯æŒå¹¶å‘æ£€æµ‹æé«˜é€Ÿåº¦ã€‚ç§»åŠ¨ç«¯è‡ªé€‚åº”ã€‚</p>
        
        <div class="grid">
            <div class="left">
                <div class="field">
                    <label>æ•°æ®æºé…ç½®åœ°å€</label>
                    <input type="url" id="configUrl" placeholder="è¾“å…¥åŒ…å«sitesæ•°ç»„çš„JSONé…ç½®åœ°å€" value="">
                </div>
                
                <div class="btn-group" style="margin-bottom: 12px;">
                    <button class="btn btn-ghost" id="getDefaultConfigBtn">è·å–é»˜è®¤é…ç½®</button>
                </div>
                
                <div class="field">
                    <label>æ£€æµ‹æ¨¡å¼</label>
                    <select id="checkMode">
                        <option value="quick">å¿«é€Ÿæ£€æµ‹ï¼ˆæ¨è+åˆ†ç±»æ¥å£ï¼‰</option>
                        <option value="full">å…¨é‡æ£€æµ‹ï¼ˆæ‰€æœ‰æ¥å£ï¼‰</option>
                    </select>
                </div>
                
                <div class="field">
                    <label>å¹¶å‘æ•°é‡</label>
                    <input type="number" id="concurrency" min="1" max="20" value="5" placeholder="åŒæ—¶æ£€æµ‹çš„ä»»åŠ¡æ•°é‡">
                    <small style="color: var(--muted); font-size: 11px; margin-top: 4px;">å»ºè®®1-10ä¸ªï¼Œè¿‡å¤šå¯èƒ½å¯¼è‡´è¯·æ±‚è¢«é™åˆ¶</small>
                </div>
                
                <div class="btn-group">
                    <button class="btn btn-primary" id="loadConfig">åŠ è½½é…ç½®</button>
                    <button class="btn btn-success" id="startCheck" disabled>å¼€å§‹æ£€æµ‹</button>
                    <button class="btn btn-warning" id="stopCheck" disabled>åœæ­¢æ£€æµ‹</button>
                    <button class="btn btn-ghost" id="clearResults">æ¸…ç©ºç»“æœ</button>
                    <button class="btn btn-info" id="exportReport" disabled>å¯¼å‡ºæŠ¥å‘Š</button>
                    <button class="btn btn-info" id="saveReport" disabled>ä¿å­˜æŠ¥å‘Š</button>
                    <button class="btn btn-secondary" id="loadLastReport">è·å–ä¸Šæ¬¡æŠ¥å‘Š</button>
                </div>
            </div>
            
            <div class="right">
                <div class="stats">
                    <div class="stat-item filter-btn active" data-filter="all" onclick="window.sourceChecker.filterSources('all')">
                        <div class="stat-number" id="totalCount">0</div>
                        <div class="stat-label">å…¨éƒ¨</div>
                    </div>
                    <div class="stat-item filter-btn" data-filter="success" onclick="window.sourceChecker.filterSources('success')">
                        <div class="stat-number stat-success" id="successCount">0</div>
                        <div class="stat-label">æ­£å¸¸</div>
                    </div>
                    <div class="stat-item filter-btn" data-filter="error" onclick="window.sourceChecker.filterSources('error')">
                        <div class="stat-number stat-error" id="errorCount">0</div>
                        <div class="stat-label">å¼‚å¸¸</div>
                    </div>
                    <div class="stat-item filter-btn" data-filter="pending" onclick="window.sourceChecker.filterSources('pending')">
                        <div class="stat-number stat-warning" id="pendingCount">0</div>
                        <div class="stat-label">å¾…æ£€æµ‹</div>
                    </div>
                </div>
                
                <div class="progress-container">
                    <div class="progress">
                        <div class="progress-bar" id="progressBar" style="width:0%"></div>
                    </div>
                    <div class="progress-text" id="progressText">0%</div>
                </div>
                <div class="timer-text" id="timerText" style="display:none;"></div>
            </div>
        </div>
    </div>
    
    <div class="card">
        <h2 style="margin:0 0 12px;font-size:16px">æ£€æµ‹æ—¥å¿—</h2>
        <div class="log" id="logContainer"></div>
    </div>
    
    <div class="card">
        <h2 style="margin:0 0 12px;font-size:16px">æ£€æµ‹ç»“æœ</h2>
        <div id="sourceList"></div>
    </div>
</div>

<script>
class SourceChecker {
    constructor() {
        this.sources = [];
        this.isChecking = false;
        this.currentIndex = 0;
        this.results = new Map();
        this.currentFilter = 'all'; // å½“å‰ç­›é€‰çŠ¶æ€
        this.startTime = null;
        this.timerInterval = null;
        
        this.initElements();
        this.bindEvents();
        
        // é¡µé¢åŠ è½½æ—¶è‡ªåŠ¨è·å–é»˜è®¤é…ç½®
        this.getDefaultConfig();
    }
    
    initElements() {
        this.configUrl = document.getElementById('configUrl');
        this.checkModeSelect = document.getElementById('checkMode');
        this.concurrencyInput = document.getElementById('concurrency');
        this.loadConfigBtn = document.getElementById('loadConfig');
        this.startCheckBtn = document.getElementById('startCheck');
        this.stopCheckBtn = document.getElementById('stopCheck');
        this.clearResultsBtn = document.getElementById('clearResults');
        this.exportReportBtn = document.getElementById('exportReport');
        this.saveReportBtn = document.getElementById('saveReport');
        this.loadLastReportBtn = document.getElementById('loadLastReport');
        this.getDefaultConfigBtn = document.getElementById('getDefaultConfigBtn');
        this.statusIndicator = document.getElementById('statusIndicator');
        this.sourceList = document.getElementById('sourceList');
        this.logContainer = document.getElementById('logContainer');
        this.progressBar = document.getElementById('progressBar');
        this.progressText = document.getElementById('progressText');
        this.timerText = document.getElementById('timerText');
        
        this.totalCount = document.getElementById('totalCount');
        this.successCount = document.getElementById('successCount');
        this.errorCount = document.getElementById('errorCount');
        this.pendingCount = document.getElementById('pendingCount');
    }
    
    bindEvents() {
        this.loadConfigBtn.addEventListener('click', () => this.loadConfig());
        this.startCheckBtn.addEventListener('click', () => this.startCheck());
        this.stopCheckBtn.addEventListener('click', () => this.stopCheck());
        this.clearResultsBtn.addEventListener('click', () => this.clearResults());
        this.exportReportBtn.addEventListener('click', () => this.exportReport());
        this.saveReportBtn.addEventListener('click', () => this.saveReport());
        this.loadLastReportBtn.addEventListener('click', () => this.loadLastReport());
        this.getDefaultConfigBtn.addEventListener('click', () => this.getDefaultConfig());
        this.checkModeSelect.addEventListener('change', (e) => {
            // æ£€æµ‹æ¨¡å¼å˜æ›´äº‹ä»¶å¤„ç†
        });
    }
    
    log(message, type = 'info') {
        const timestamp = new Date().toLocaleTimeString();
        const entry = document.createElement('div');
        entry.className = `log-entry log-${type}`;
        entry.textContent = `[${timestamp}] ${message}`;
        this.logContainer.appendChild(entry);
        this.logContainer.scrollTop = this.logContainer.scrollHeight;
    }
    
    async loadConfig() {
        const url = this.configUrl.value.trim();
        if (!url) {
            this.log('è¯·è¾“å…¥é…ç½®åœ°å€', 'error');
            return;
        }
        
        try {
            this.log('æ­£åœ¨åŠ è½½é…ç½®...');
            const response = await fetch(url);
            if (!response.ok) throw new Error(`HTTP ${response.status}`);
            
            const config = await response.json();
            if (!config.sites || !Array.isArray(config.sites)) {
                throw new Error('é…ç½®æ ¼å¼é”™è¯¯ï¼šç¼ºå°‘sitesæ•°ç»„');
            }
            
            // åªä¿ç•™typeä¸º4çš„æº
            this.sources = config.sites.filter(site => site.type === 4);
            this.log(`åŠ è½½æˆåŠŸï¼Œæ‰¾åˆ° ${this.sources.length} ä¸ªtype=4çš„æº`);
            
            this.updateStats();
            this.renderSourceList();
            this.startCheckBtn.disabled = this.sources.length === 0;
            
        } catch (error) {
            this.log(`åŠ è½½é…ç½®å¤±è´¥: ${error.message}`, 'error');
        }
    }
    
    renderSourceList() {
        // å¦‚æœæœ‰ç­›é€‰çŠ¶æ€ï¼Œä½¿ç”¨ç­›é€‰æ¸²æŸ“
        if (this.currentFilter && this.currentFilter !== 'all') {
            const filteredSources = this.getFilteredSources();
            this.renderFilteredSourceList(filteredSources);
            return;
        }
        
        this.sourceList.innerHTML = '';
        
        this.sources.forEach((source, index) => {
            const item = document.createElement('div');
            item.className = 'source-item';
            
            // è·å–æ£€æµ‹ç»“æœ
            const result = this.results.get(source.key);
            let statusText = 'å¾…æ£€æµ‹';
            let statusClass = 'status-pending';
            let resultsHtml = '';
            
            if (result) {
                if (result.status === 'success') {
                    statusText = 'æ­£å¸¸';
                    statusClass = 'status-success';
                    if (result.testUrl) {
                        resultsHtml = `<div class="result-content"><a href="${result.testUrl}" target="_blank" class="test-link">æµ‹è¯•é“¾æ¥</a></div>`;
                    }
                } else if (result.status === 'error') {
                    statusText = 'å¼‚å¸¸';
                    statusClass = 'status-error';
                    if (result.message) {
                        resultsHtml = `<div class="result-content error-message">${result.message}</div>`;
                    }
                }
            }
            
            item.innerHTML = `
                <div class="source-header">
                    <div class="source-info">
                        <div class="source-name">${source.name}</div>
                        <div class="source-url">${source.api}</div>
                    </div>
                    <div class="source-actions">
                        <div class="source-status ${statusClass}" id="status-${index}">${statusText}</div>
                        <button class="manual-check-btn" onclick="window.sourceChecker.manualCheckSource('${source.key}')" title="æ‰‹åŠ¨å…¨é‡æ£€æµ‹">ğŸ”</button>
                        <button class="manual-mark-btn" onclick="window.sourceChecker.toggleSourceStatus('${source.key}')" title="æ‰‹åŠ¨æ ‡è®°çŠ¶æ€">ğŸ·ï¸</button>
                    </div>
                </div>
                ${resultsHtml}
                <div class="source-details">
                    <div>API: ${source.api}</div>
                    <div>è¯­è¨€: ${source.lang || 'unknown'} | æœç´¢: ${source.searchable ? 'æ”¯æŒ' : 'ä¸æ”¯æŒ'}</div>
                </div>
                <div class="source-results" id="results-${index}">${resultsHtml}</div>
            `;
            this.sourceList.appendChild(item);
        });
    }
    
    updateStats() {
        const total = this.sources.length;
        const success = Array.from(this.results.values()).filter(r => r.status === 'success').length;
        const error = Array.from(this.results.values()).filter(r => r.status === 'error').length;
        const pending = total - success - error;
        
        this.totalCount.textContent = total;
        this.successCount.textContent = success;
        this.errorCount.textContent = error;
        this.pendingCount.textContent = pending;
        
        const progress = total > 0 ? ((success + error) / total) * 100 : 0;
        this.progressBar.style.width = `${progress}%`;
        this.progressText.textContent = `${Math.round(progress)}%`;
    }
    
    async startCheck() {
        if (this.sources.length === 0) {
            this.log('è¯·å…ˆåŠ è½½é…ç½®', 'error');
            return;
        }
        
        this.isChecking = true;
        this.currentIndex = 0;
        this.results.clear();
        
        // éšè—å†å²æŠ¥å‘ŠçŠ¶æ€æŒ‡ç¤ºå™¨ï¼Œè¿›å…¥å®æ—¶æ£€æµ‹æ¨¡å¼
        this.statusIndicator.classList.add('hidden');
        
        // å¼€å§‹è®¡æ—¶
        this.startTime = Date.now();
        this.timerText.style.display = 'block';
        this.timerText.textContent = 'æ£€æµ‹ä¸­ï¼Œå·²è€—æ—¶ 0 ç§’';
        this.startTimer();
        
        this.startCheckBtn.disabled = true;
        this.stopCheckBtn.disabled = false;
        this.loadConfigBtn.disabled = true;
        
        const concurrency = parseInt(this.concurrencyInput.value) || 5;
        const mode = this.checkModeSelect.value;
        
        this.log(`å¼€å§‹${mode === 'quick' ? 'å¿«é€Ÿ' : 'å…¨é‡'}æ£€æµ‹ï¼Œå¹¶å‘æ•°: ${concurrency}...`);
        
        await this.checkSourcesConcurrently(concurrency);
        
        if (this.isChecking) {
            this.log('æ£€æµ‹å®Œæˆ');
            this.stopCheck();
        }
    }
    
    async checkSourcesConcurrently(concurrency) {
        const total = this.sources.length;
        let completed = 0;
        
        // åˆ›å»ºä»»åŠ¡é˜Ÿåˆ—
        const tasks = this.sources.map((source, index) => ({ source, index }));
        
        // å¹¶å‘æ‰§è¡Œä»»åŠ¡
        const executeTask = async (task) => {
            if (!this.isChecking) return;
            
            try {
                await this.checkSource(task.source, task.index);
            } catch (error) {
                this.log(`æ£€æµ‹æº ${task.source.name} æ—¶å‡ºé”™: ${error.message}`, 'error');
            }
            
            completed++;
            this.log(`è¿›åº¦: ${completed}/${total}`, 'info');
        };
        
        // åˆ†æ‰¹æ‰§è¡Œï¼Œæ§åˆ¶å¹¶å‘æ•°
        for (let i = 0; i < tasks.length; i += concurrency) {
            if (!this.isChecking) break;
            
            const batch = tasks.slice(i, i + concurrency);
            const promises = batch.map(executeTask);
            
            await Promise.allSettled(promises);
            
            // æ‰¹æ¬¡é—´ç¨ä½œå»¶è¿Ÿï¼Œé¿å…è¯·æ±‚è¿‡äºå¯†é›†
            if (i + concurrency < tasks.length && this.isChecking) {
                await this.delay(200);
            }
        }
    }
    
    startTimer() {
        this.timerInterval = setInterval(() => {
            if (this.startTime && this.isChecking) {
                const elapsed = Math.round((Date.now() - this.startTime) / 1000);
                this.timerText.textContent = `æ£€æµ‹ä¸­ï¼Œå·²è€—æ—¶ ${elapsed} ç§’`;
            }
        }, 1000);
    }
    
    stopCheck() {
        this.isChecking = false;
        
        // åœæ­¢è®¡æ—¶
        if (this.timerInterval) {
            clearInterval(this.timerInterval);
            this.timerInterval = null;
        }
        
        // æ˜¾ç¤ºæ€»è€—æ—¶
        if (this.startTime) {
            const totalTime = Math.round((Date.now() - this.startTime) / 1000);
            this.timerText.textContent = `æ£€æµ‹å®Œæ¯•ï¼Œæœ¬è½®æ£€æµ‹å…±è®¡è€—æ—¶ ${totalTime} ç§’`;
            this.log(`æ£€æµ‹å®Œæ¯•ï¼Œæœ¬è½®æ£€æµ‹å…±è®¡è€—æ—¶ ${totalTime} ç§’`);
        }
        
        this.startCheckBtn.disabled = false;
        this.stopCheckBtn.disabled = true;
        this.loadConfigBtn.disabled = false;
        this.exportReportBtn.disabled = this.results.size === 0;
        this.saveReportBtn.disabled = this.results.size === 0;
    }
    
    async checkSource(source, index) {
        const statusEl = document.getElementById(`status-${index}`);
        const resultsEl = document.getElementById(`results-${index}`);
        
        statusEl.textContent = 'æ£€æµ‹ä¸­...';
        statusEl.className = 'status status-warning';
        
        try {
            const result = {
                status: 'error',
                details: {},
                message: ''
            };
            
            // æ„å»ºåŸºç¡€API URLå’Œå‚æ•°
            const baseUrl = source.api;
            const extend = this.getExtendParam(source.ext);
            
            if (this.checkModeSelect.value === 'quick') {
                // å¿«é€Ÿæ£€æµ‹ï¼šæ¨èæ¥å£ + ä¸€çº§åˆ†ç±»æ¥å£
                await this.quickCheck(source, result, extend);
            } else {
                // å…¨é‡æ£€æµ‹ï¼šæ‰€æœ‰æ¥å£
                await this.fullCheck(source, result, extend);
            }
            
            this.results.set(source.key, result);
            this.updateSourceDisplay(index, result);
            
        } catch (error) {
            const result = {
                status: 'error',
                details: {},
                message: error.message
            };
            this.results.set(source.key, result);
            this.updateSourceDisplay(index, result);
            this.log(`${source.name}: ${error.message}`, 'error');
        }
        
        this.updateStats();
    }
    
    getExtendParam(ext) {
        if (!ext) return '';
        if (typeof ext === 'string') return ext;
        if (typeof ext === 'object') return JSON.stringify(ext);
        return '';
    }
    
    async quickCheck(source, result, extend) {
        // 1. æ£€æµ‹æ¨èæ¥å£ï¼ˆé¦–é¡µï¼‰
        const homeResult = await this.testApi(source.api, { extend });
        result.details.home = homeResult;
        
        const homeSuccess = homeResult.success && this.isValidData(homeResult.data);
        if (homeSuccess) {
            result.status = 'success';
            result.message = 'æ¨èæ¥å£æ­£å¸¸';
            this.log(`${source.name}: æ¨èæ¥å£æ­£å¸¸`, 'success');
            return;
        }
        
        // 2. å¦‚æœæ¨èæ¥å£å¼‚å¸¸ï¼Œæ£€æµ‹ä¸€çº§åˆ†ç±»æ¥å£
        let categorySuccess = false;
        if (homeResult.data && homeResult.data.class && homeResult.data.class.length > 0) {
            const firstCategory = homeResult.data.class[0];
            if (firstCategory.type_id) {
                const cateResult = await this.testApi(source.api, {
                    ac: 'list',
                    t: firstCategory.type_id,
                    pg: 1,
                    extend
                });
                result.details.category = cateResult;
                
                categorySuccess = cateResult.success && this.isValidData(cateResult.data);
                if (categorySuccess) {
                    result.status = 'success';
                    result.message = 'åˆ†ç±»æ¥å£æ­£å¸¸';
                    this.log(`${source.name}: åˆ†ç±»æ¥å£æ­£å¸¸`, 'success');
                    return;
                }
            }
        }
        
        // 3. æ¨èå’Œåˆ†ç±»éƒ½å¼‚å¸¸æ—¶ï¼Œç›´æ¥æ ‡è®°ä¸ºå¼‚å¸¸
        result.status = 'error';
        result.message = 'æ¨èå’Œåˆ†ç±»æ¥å£å‡å¼‚å¸¸';
        this.log(`${source.name}: æ¨èå’Œåˆ†ç±»æ¥å£å‡å¼‚å¸¸`, 'error');
    }
    
    async fullCheck(source, result, extend) {
        // å…ˆæ£€æµ‹æ¨èå’Œåˆ†ç±»æ¥å£
        const coreTests = [
            { name: 'home', params: { extend } },
            { name: 'category', params: { ac: 'list', t: '1', pg: 1, extend } }
        ];
        
        let coreSuccessCount = 0;
        
        // æ£€æµ‹æ ¸å¿ƒæ¥å£ï¼ˆæ¨èå’Œåˆ†ç±»ï¼‰
        for (const test of coreTests) {
            try {
                const testResult = await this.testApi(source.api, test.params);
                result.details[test.name] = testResult;
                
                if (testResult.success && this.isValidData(testResult.data)) {
                    coreSuccessCount++;
                }
            } catch (error) {
                result.details[test.name] = { success: false, error: error.message };
            }
        }
        
        // å¦‚æœæ¨èå’Œåˆ†ç±»éƒ½å¼‚å¸¸ï¼Œç›´æ¥è¿”å›å¼‚å¸¸ç»“æœ
        if (coreSuccessCount === 0) {
            result.status = 'error';
            result.message = 'æ¨èå’Œåˆ†ç±»æ¥å£å‡å¼‚å¸¸';
            this.log(`${source.name}: æ¨èå’Œåˆ†ç±»æ¥å£å‡å¼‚å¸¸`, 'error');
            return;
        }
        
        // å¦‚æœè‡³å°‘æœ‰ä¸€ä¸ªæ ¸å¿ƒæ¥å£æ­£å¸¸ï¼Œç»§ç»­æ£€æµ‹å…¶ä»–æ¥å£
        const additionalTests = [
            { name: 'search', params: { wd: 'æµ‹è¯•', extend } },
            { name: 'detail', params: { ac: 'detail', ids: '1', extend } }
        ];
        
        let totalSuccessCount = coreSuccessCount;
        
        for (const test of additionalTests) {
            try {
                const testResult = await this.testApi(source.api, test.params);
                result.details[test.name] = testResult;
                
                if (testResult.success) {
                    totalSuccessCount++;
                }
            } catch (error) {
                result.details[test.name] = { success: false, error: error.message };
            }
        }
        
        if (totalSuccessCount >= 2) {
            result.status = 'success';
            result.message = `${totalSuccessCount}/4 æ¥å£æ­£å¸¸`;
            this.log(`${source.name}: ${totalSuccessCount}/4 æ¥å£æ­£å¸¸`, 'success');
        } else {
            result.status = 'error';
            result.message = `ä»… ${totalSuccessCount}/4 æ¥å£æ­£å¸¸`;
            this.log(`${source.name}: ä»… ${totalSuccessCount}/4 æ¥å£æ­£å¸¸`, 'error');
        }
    }
    
    async testApi(baseUrl, params) {
        try {
            const url = new URL(baseUrl);
            Object.keys(params).forEach(key => {
                if (params[key] !== undefined && params[key] !== '') {
                    url.searchParams.set(key, params[key]);
                }
            });
            
            const response = await fetch(url.toString(), {
                method: 'GET',
                timeout: 10000
            });
            
            if (!response.ok) {
                throw new Error(`HTTP ${response.status}`);
            }
            
            const data = await response.json();
            return { success: true, data };
            
        } catch (error) {
            return { success: false, error: error.message };
        }
    }
    
    isValidData(data) {
        if (!data || !data.list || !Array.isArray(data.list)) {
            return false;
        }
        
        // æ£€æŸ¥æ˜¯å¦åªæœ‰æ— æ•ˆæ•°æ®
        const validItems = data.list.filter(item => 
            item.vod_id !== 'no_data' && 
            item.vod_name !== 'æ— æ•°æ®,é˜²æ— é™è¯·æ±‚'
        );
        
        return validItems.length > 0;
    }
    
    updateSourceDisplay(index, result) {
        const statusEl = document.getElementById(`status-${index}`);
        const resultsEl = document.getElementById(`results-${index}`);
        
        // æ›´æ–°çŠ¶æ€
        statusEl.textContent = result.status === 'success' ? 'æ­£å¸¸' : 'å¼‚å¸¸';
        statusEl.className = `status status-${result.status === 'success' ? 'success' : 'error'}`;
        
        // æ›´æ–°è¯¦ç»†ç»“æœ
        resultsEl.innerHTML = '';
        Object.keys(result.details).forEach(key => {
            const detail = result.details[key];
            const item = document.createElement('div');
            item.className = 'result-item';
            item.innerHTML = `
                <span class="result-label">${this.getTestName(key)}</span>
                <span class="result-status" style="color: ${detail.success ? 'var(--success)' : 'var(--error)'}">
                    ${detail.success ? 'âœ“' : 'âœ—'}
                </span>
            `;
            resultsEl.appendChild(item);
        });
        
        if (result.message) {
            const messageItem = document.createElement('div');
            messageItem.style.gridColumn = '1 / -1';
            messageItem.style.fontSize = '11px';
            messageItem.style.color = 'var(--muted)';
            messageItem.style.marginTop = '4px';
            messageItem.textContent = result.message;
            resultsEl.appendChild(messageItem);
        }
    }
    
    getTestName(key) {
        const names = {
            home: 'æ¨è',
            category: 'åˆ†ç±»',
            search: 'æœç´¢',
            detail: 'è¯¦æƒ…',
            play: 'æ’­æ”¾'
        };
        return names[key] || key;
    }
    
    clearResults() {
        this.results.clear();
        this.renderSourceList();
        this.updateStats();
        this.logContainer.innerHTML = '';
        this.exportReportBtn.disabled = true;
        this.saveReportBtn.disabled = true;
        
        // éšè—å†å²æŠ¥å‘ŠçŠ¶æ€æŒ‡ç¤ºå™¨ï¼Œæ¢å¤å®æ—¶æ£€æµ‹æ¨¡å¼
        this.statusIndicator.classList.add('hidden');
        
        this.log('ç»“æœå·²æ¸…ç©º');
    }
    
    exportReport() {
        if (this.results.size === 0) {
            alert('æ²¡æœ‰æ£€æµ‹ç»“æœå¯å¯¼å‡ºï¼Œè¯·å…ˆè¿›è¡Œæ£€æµ‹');
            return;
        }
        
        const report = this.generateReportData();
        
        // ç”Ÿæˆæ–‡ä»¶å
        const timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, 19);
        const filename = `source-check-report-${timestamp}.json`;
        
        // ä¸‹è½½æ–‡ä»¶
        const blob = new Blob([JSON.stringify(report, null, 2)], { type: 'application/json' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = filename;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
        
        this.log(`æ£€æµ‹æŠ¥å‘Šå·²å¯¼å‡º: ${filename}`);
    }
    
    async getDefaultConfig() {
        try {
            this.log('æ­£åœ¨è·å–é»˜è®¤é…ç½®åœ°å€...');
            const response = await fetch('/source-checker/config/default');
            if (!response.ok) throw new Error(`HTTP ${response.status}`);
            
            const data = await response.json();
            if (data.configUrl) {
                this.configUrl.value = data.configUrl;
                this.log(`å·²è®¾ç½®é»˜è®¤é…ç½®åœ°å€: ${data.configUrl}`, 'success');
            } else {
                throw new Error('æœåŠ¡å™¨æœªè¿”å›é…ç½®åœ°å€');
            }
        } catch (error) {
            this.log(`è·å–é»˜è®¤é…ç½®å¤±è´¥: ${error.message}`, 'error');
        }
    }
    
    async saveReport() {
        if (this.results.size === 0) {
            alert('æ²¡æœ‰æ£€æµ‹ç»“æœå¯ä¿å­˜ï¼Œè¯·å…ˆè¿›è¡Œæ£€æµ‹');
            return;
        }

        try {
            this.log('æ­£åœ¨éªŒè¯é…ç½®æ¥æº...');
            
            // è·å–é»˜è®¤é…ç½®åœ°å€è¿›è¡ŒåŒæºéªŒè¯
            const defaultConfigResponse = await fetch('/source-checker/config/default');
            if (!defaultConfigResponse.ok) {
                throw new Error('æ— æ³•è·å–é»˜è®¤é…ç½®åœ°å€');
            }
            
            const defaultConfigData = await defaultConfigResponse.json();
            const currentConfigUrl = this.configUrl.value.trim();
            const defaultConfigUrl = defaultConfigData.configUrl;
            
            // åŒæºéªŒè¯ï¼šæ£€æŸ¥å½“å‰é…ç½®URLæ˜¯å¦ä¸é»˜è®¤é…ç½®URLä¸€è‡´
            if (currentConfigUrl !== defaultConfigUrl) {
                const confirmSave = confirm(
                    `æ£€æµ‹åˆ°æ‚¨ä½¿ç”¨çš„é…ç½®åœ°å€ä¸æœ¬æœåŠ¡å™¨é»˜è®¤é…ç½®ä¸ä¸€è‡´ï¼š\n\n` +
                    `å½“å‰é…ç½®ï¼š${currentConfigUrl}\n` +
                    `é»˜è®¤é…ç½®ï¼š${defaultConfigUrl}\n\n` +
                    `è¿™å¯èƒ½æ˜¯æ£€æµ‹çš„è¿œç¨‹é…ç½®ï¼Œç¡®å®šè¦ä¿å­˜åˆ°æœ¬æœåŠ¡å™¨å—ï¼Ÿ`
                );
                
                if (!confirmSave) {
                    this.log('ç”¨æˆ·å–æ¶ˆä¿å­˜æ“ä½œ', 'warning');
                    return;
                }
            }
            
            this.log('æ­£åœ¨ä¿å­˜æŠ¥å‘Šåˆ°æœåŠ¡å™¨...');
            
            const report = this.generateReportData();
            
            const response = await fetch('/source-checker/reports/save', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify(report)
            });
            
            if (!response.ok) {
                const errorData = await response.json().catch(() => ({}));
                throw new Error(errorData.message || `HTTP ${response.status}`);
            }
            
            const result = await response.json();
            
            // æ˜¾ç¤ºæˆåŠŸæç¤º
            this.log(`âœ… æŠ¥å‘Šä¿å­˜æˆåŠŸï¼æ–‡ä»¶è·¯å¾„: ${result.path || 'data/source-checker/report.json'}`, 'success');
            alert('æ£€æµ‹æŠ¥å‘Šå·²æˆåŠŸä¿å­˜åˆ°æœåŠ¡å™¨ï¼');
            
        } catch (error) {
            this.log(`âŒ ä¿å­˜æŠ¥å‘Šå¤±è´¥: ${error.message}`, 'error');
            alert(`ä¿å­˜å¤±è´¥: ${error.message}`);
        }
    }
    
    generateReportData() {
        const report = {
            exportTime: new Date().toISOString(),
            configUrl: this.configUrl.value.trim(), // è®°å½•æ£€æµ‹æ—¶ä½¿ç”¨çš„é…ç½®åœ°å€
            totalSources: this.results.size,
            summary: {
                success: 0,
                error: 0,
                pending: 0
            },
            sources: []
        };
        
        // ç»Ÿè®¡å’Œæ”¶é›†æºä¿¡æ¯
        this.results.forEach((result, sourceKey) => {
            const source = this.sources.find(s => s.key === sourceKey);
            const extend = this.getExtendParam(source.ext);
            
            // æ„å»ºæµ‹è¯•URLè€Œä¸æ˜¯ä¿å­˜å®Œæ•´æ•°æ®
            const testUrls = {};
            if (result.details) {
                // æ¨èæ¥å£URL
                if (result.details.home) {
                    const homeUrl = new URL(source.api);
                    if (extend) homeUrl.searchParams.set('extend', extend);
                    testUrls.home = homeUrl.toString();
                }
                
                // åˆ†ç±»æ¥å£URL
                if (result.details.category) {
                    const cateUrl = new URL(source.api);
                    cateUrl.searchParams.set('ac', 'list');
                    cateUrl.searchParams.set('t', '1'); // ä½¿ç”¨ç¬¬ä¸€ä¸ªåˆ†ç±»ID
                    cateUrl.searchParams.set('pg', '1');
                    if (extend) cateUrl.searchParams.set('extend', extend);
                    testUrls.category = cateUrl.toString();
                }
                
                // æœç´¢æ¥å£URL
                if (result.details.search) {
                    const searchUrl = new URL(source.api);
                    searchUrl.searchParams.set('ac', 'list');
                    searchUrl.searchParams.set('wd', 'æµ‹è¯•');
                    if (extend) searchUrl.searchParams.set('extend', extend);
                    testUrls.search = searchUrl.toString();
                }
                
                // è¯¦æƒ…æ¥å£URL
                if (result.details.detail) {
                    const detailUrl = new URL(source.api);
                    detailUrl.searchParams.set('ac', 'detail');
                    detailUrl.searchParams.set('ids', '1');
                    if (extend) detailUrl.searchParams.set('extend', extend);
                    testUrls.detail = detailUrl.toString();
                }
                
                // æ’­æ”¾æ¥å£URL
                if (result.details.play) {
                    const playUrl = new URL(source.api);
                    playUrl.searchParams.set('ac', 'play');
                    playUrl.searchParams.set('id', '1');
                    playUrl.searchParams.set('play', '1');
                    if (extend) playUrl.searchParams.set('extend', extend);
                    testUrls.play = playUrl.toString();
                }
            }
            
            const sourceInfo = {
                key: source.key,
                name: source.name || source.key,
                api: source.api,
                type: source.type,
                searchable: source.searchable,
                lang: source.lang || 'unknown',
                status: result.status,
                message: result.message || '',
                testUrls: testUrls,
                checkTime: new Date().toISOString(),
                manuallyMarked: result.manuallyMarked || false // ä¿å­˜æ‰‹åŠ¨æ ‡è®°çŠ¶æ€
            };
            
            report.sources.push(sourceInfo);
            report.summary[result.status]++;
        });
        
        // æŒ‰çŠ¶æ€æ’åºï¼šæˆåŠŸ -> é”™è¯¯ -> å¾…æ£€æµ‹
        report.sources.sort((a, b) => {
            const statusOrder = { success: 0, error: 1, pending: 2 };
            return statusOrder[a.status] - statusOrder[b.status];
        });
        
        return report;
    }
    
    async loadLastReport() {
        try {
            this.log('æ­£åœ¨è·å–ä¸Šæ¬¡æŠ¥å‘Š...', 'info');
            
            const response = await fetch('/source-checker/reports/latest', {
                method: 'GET',
                headers: {
                    'Content-Type': 'application/json'
                }
            });
            
            if (!response.ok) {
                throw new Error(`HTTP ${response.status}: ${response.statusText}`);
            }
            
            const responseData = await response.json();
            
            if (!responseData.success || !responseData.data) {
                throw new Error(responseData.error || 'è·å–æŠ¥å‘Šå¤±è´¥');
            }
            
            const reportData = responseData.data;
            
            if (!reportData || !reportData.sources) {
                throw new Error('æŠ¥å‘Šæ•°æ®æ ¼å¼æ— æ•ˆæˆ–æ— æºæ•°æ®');
            }
            
            this.log(`æˆåŠŸè·å–ä¸Šæ¬¡æŠ¥å‘Šï¼ŒåŒ…å« ${reportData.sources.length} ä¸ªæºç«™`, 'success');
            this.displayLastReport(reportData);
            
        } catch (error) {
            this.log(`è·å–ä¸Šæ¬¡æŠ¥å‘Šå¤±è´¥: ${error.message}`, 'error');
            console.error('è·å–ä¸Šæ¬¡æŠ¥å‘Šå¤±è´¥:', error);
        }
    }
    
    displayLastReport(reportData) {
        try {
            // æ¸…ç©ºå½“å‰ç»“æœ
            this.sourceList.innerHTML = '';
            this.sources = [];
            this.results = new Map();
            
            // è®¾ç½®é…ç½®URLï¼ˆå¦‚æœæŠ¥å‘Šä¸­æœ‰è®°å½•ï¼‰
            if (reportData.configUrl) {
                this.configUrl.value = reportData.configUrl;
            }
            
            // æ¨¡æ‹ŸåŠ è½½æºç«™æ•°æ®
            this.sources = reportData.sources.map(source => ({
                key: source.key,
                name: source.name || source.key,
                api: source.api,
                type: source.type,
                searchable: source.searchable,
                lang: source.lang || 'unknown'
            }));
            
            // è®¾ç½®æ£€æµ‹ç»“æœ
            reportData.sources.forEach(source => {
                this.results.set(source.key, {
                    status: source.status,
                    message: source.message || '',
                    testUrls: source.testUrls || [],
                    testUrl: source.testUrls && source.testUrls.home ? source.testUrls.home : '',
                    manuallyMarked: source.manuallyMarked || false // åŠ è½½æ‰‹åŠ¨æ ‡è®°çŠ¶æ€
                });
            });
            
            // æ¸²æŸ“ç•Œé¢
            this.renderSourceList();
            this.updateStats();
            
            // å¯ç”¨ç›¸å…³æŒ‰é’®
            this.exportReportBtn.disabled = false;
            this.saveReportBtn.disabled = false;
            
            // æ˜¾ç¤ºå†å²æŠ¥å‘ŠçŠ¶æ€æŒ‡ç¤ºå™¨
            const timestamp = reportData.exportTime ? new Date(reportData.exportTime).toLocaleString() : 'æœªçŸ¥æ—¶é—´';
            this.statusIndicator.innerHTML = `ğŸ“Š å½“å‰æ˜¾ç¤ºå†å²æŠ¥å‘Šæ•°æ® (ç”Ÿæˆæ—¶é—´: ${timestamp})`;
            this.statusIndicator.classList.remove('hidden');
            
            this.log(`å·²æ˜¾ç¤ºå†å²æŠ¥å‘Š (ç”Ÿæˆæ—¶é—´: ${timestamp})`, 'info');
            
        } catch (error) {
            this.log(`æ˜¾ç¤ºå†å²æŠ¥å‘Šå¤±è´¥: ${error.message}`, 'error');
            console.error('æ˜¾ç¤ºå†å²æŠ¥å‘Šå¤±è´¥:', error);
        }
    }
    
   async delay(ms) {
        return new Promise(resolve => setTimeout(resolve, ms));
    }

    // ç­›é€‰æºåˆ—è¡¨
    filterSources(filter) {
        this.currentFilter = filter;
        
        // æ›´æ–°ç­›é€‰æŒ‰é’®çŠ¶æ€
        document.querySelectorAll('.filter-btn').forEach(btn => {
            btn.classList.remove('active');
        });
        document.querySelector(`[data-filter="${filter}"]`).classList.add('active');
        
        // ç­›é€‰å¹¶æ˜¾ç¤ºæºåˆ—è¡¨
        const filteredSources = this.getFilteredSources();
        this.renderFilteredSourceList(filteredSources);
    }

    // è·å–ç­›é€‰åçš„æºåˆ—è¡¨
    getFilteredSources() {
        if (this.currentFilter === 'all') {
            return this.sources;
        }
        
        return this.sources.filter(source => {
            const result = this.results.get(source.key);
            
            switch (this.currentFilter) {
                case 'success':
                    return result && result.status === 'success';
                case 'error':
                    return result && result.status === 'error';
                case 'pending':
                    return !result || result.status === 'pending';
                default:
                    return true;
            }
        });
    }

    // æ¸²æŸ“ç­›é€‰åçš„æºåˆ—è¡¨
    renderFilteredSourceList(sources) {
        this.sourceList.innerHTML = '';
        
        sources.forEach(source => {
            const sourceElement = document.createElement('div');
            sourceElement.className = 'source-item';
            
            // æ‰¾åˆ°æºçš„åŸå§‹ç´¢å¼•
            const originalIndex = this.sources.findIndex(s => s.key === source.key);
            
            const result = this.results.get(source.key);
            let statusText = 'å¾…æ£€æµ‹';
            let statusClass = 'status-pending';
            let resultHtml = '';
            
            if (result) {
                if (result.status === 'success') {
                    statusText = 'æ­£å¸¸';
                    statusClass = 'status-success';
                    if (result.testUrl) {
                        resultHtml = `<div class="result-content"><a href="${result.testUrl}" target="_blank" class="test-link">æµ‹è¯•é“¾æ¥</a></div>`;
                    }
                } else if (result.status === 'error') {
                    statusText = 'å¼‚å¸¸';
                    statusClass = 'status-error';
                    if (result.message) {
                        resultHtml = `<div class="result-content error-message">${result.message}</div>`;
                    }
                }
            }
            
            sourceElement.innerHTML = `
                <div class="source-header">
                    <div class="source-info">
                        <div class="source-name">${source.name}</div>
                        <div class="source-url">${source.api}</div>
                    </div>
                    <div class="source-actions">
                        <div class="source-status ${statusClass}" id="status-${originalIndex}">${statusText}</div>
                        <button class="manual-check-btn" onclick="window.sourceChecker.manualCheckSource('${source.key}')" title="æ‰‹åŠ¨å…¨é‡æ£€æµ‹">ğŸ”</button>
                        <button class="manual-mark-btn" onclick="window.sourceChecker.toggleSourceStatus('${source.key}')" title="æ‰‹åŠ¨æ ‡è®°çŠ¶æ€">ğŸ·ï¸</button>
                    </div>
                </div>
                ${resultHtml}
                <div class="source-results" id="results-${originalIndex}"></div>
            `;
            
            this.sourceList.appendChild(sourceElement);
        });
     }

     // æ‰‹åŠ¨æ£€æµ‹å•ä¸ªæº
     async manualCheckSource(sourceKey) {
         const source = this.sources.find(s => s.key === sourceKey);
         if (!source) {
             this.log(`æœªæ‰¾åˆ°æº: ${sourceKey}`, 'error');
             return;
         }
         
         this.log(`å¼€å§‹æ‰‹åŠ¨æ£€æµ‹æº: ${source.name}`, 'info');
         
         // å¼ºåˆ¶ä½¿ç”¨å…¨é‡æ£€æµ‹æ¨¡å¼
         const originalMode = this.checkModeSelect.value;
         this.checkModeSelect.value = 'full';
         
         try {
             await this.checkSource(source, this.sources.indexOf(source));
             this.log(`æ‰‹åŠ¨æ£€æµ‹å®Œæˆ: ${source.name}`, 'info');
             // é‡æ–°æ¸²æŸ“å½“å‰ç­›é€‰çš„åˆ—è¡¨
             const filteredSources = this.getFilteredSources();
             this.renderFilteredSourceList(filteredSources);
         } catch (error) {
             this.log(`æ‰‹åŠ¨æ£€æµ‹å¤±è´¥: ${source.name} - ${error.message}`, 'error');
         } finally {
             // æ¢å¤åŸå§‹æ£€æµ‹æ¨¡å¼
             this.checkModeSelect.value = originalMode;
         }
     }
     
     // æ‰‹åŠ¨æ ‡è®°æºçŠ¶æ€
     toggleSourceStatus(sourceKey) {
        const source = this.sources.find(s => s.key === sourceKey);
        if (!source) {
            this.log(`æœªæ‰¾åˆ°æº: ${sourceKey}`, 'error');
            return;
        }
        
        const currentResult = this.results.get(sourceKey) || { status: 'pending', message: '', testUrls: [] };
        let newStatus, newMessage;
        
        // åˆ‡æ¢çŠ¶æ€é€»è¾‘
        switch (currentResult.status) {
            case 'success':
                newStatus = 'error';
                newMessage = 'æ‰‹åŠ¨æ ‡è®°ä¸ºå¼‚å¸¸';
                break;
            case 'error':
                newStatus = 'success';
                newMessage = 'æ‰‹åŠ¨æ ‡è®°ä¸ºæ­£å¸¸';
                break;
            case 'pending':
            default:
                newStatus = 'success';
                newMessage = 'æ‰‹åŠ¨æ ‡è®°ä¸ºæ­£å¸¸';
                break;
        }
        
        // æ›´æ–°ç»“æœ
        const newResult = {
            ...currentResult,
            status: newStatus,
            message: newMessage,
            manuallyMarked: true // æ ‡è®°ä¸ºæ‰‹åŠ¨ä¿®æ”¹
        };
        
        this.results.set(sourceKey, newResult);
        this.updateStats();
        
        // é‡æ–°æ¸²æŸ“å½“å‰ç­›é€‰çš„åˆ—è¡¨
        const filteredSources = this.getFilteredSources();
        this.renderFilteredSourceList(filteredSources);
        
        this.log(`æ‰‹åŠ¨æ ‡è®°æº ${source.name} ä¸º ${newStatus === 'success' ? 'æ­£å¸¸' : 'å¼‚å¸¸'}`, 'info');
    }
}

// åˆå§‹åŒ–åº”ç”¨
document.addEventListener('DOMContentLoaded', () => {
    window.sourceChecker = new SourceChecker();
});
</script>
</body>
</html>